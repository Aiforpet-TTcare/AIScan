// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1 effective-5.10 (swiftlang-6.1.0.110.21 clang-1700.0.13.3)
// swift-module-flags: -target arm64-apple-ios15.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name AIScan
// swift-module-flags-ignorable:  -interface-compiler-version 6.1
@_exported import AIScan
import ARKit
import AVFoundation
import AVKit
import Accelerate
import Combine
import CommonCrypto
import CoreGraphics
import CoreImage
import CoreML
import CoreMedia
import CoreMotion
import CoreVideo
import DeveloperToolsSupport
import Foundation
import ImageIO
import Photos
import Swift
import SwiftUI
import TensorFlowLite
import TensorFlowLiteC
import UIKit
import Vision
import VisionKit
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import simd
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class TTCameraGuideViewController : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var preferredInterfaceOrientationForPresentation: UIKit.UIInterfaceOrientation {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var shouldAutorotate: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension AIScan.TTCameraGuideViewController : WebKit.WKNavigationDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, didStartProvisionalNavigation navigation: WebKit.WKNavigation!)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WebKit.WKNavigation!)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, didFailProvisionalNavigation navigation: WebKit.WKNavigation!, withError error: any Swift.Error)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, didCommit navigation: WebKit.WKNavigation!)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, didFinish navigation: WebKit.WKNavigation!)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, didFail navigation: WebKit.WKNavigation!, withError error: any Swift.Error)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webViewWebContentProcessDidTerminate(_ webView: WebKit.WKWebView)
  @available(iOS 14.5, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, navigationAction: WebKit.WKNavigationAction, didBecome download: WebKit.WKDownload)
  @available(iOS 14.5, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, navigationResponse: WebKit.WKNavigationResponse, didBecome download: WebKit.WKDownload)
}
extension AIScan.TTCameraGuideViewController : WebKit.WKUIDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, createWebViewWith configuration: WebKit.WKWebViewConfiguration, for navigationAction: WebKit.WKNavigationAction, windowFeatures: WebKit.WKWindowFeatures) -> WebKit.WKWebView?
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webViewDidClose(_ webView: WebKit.WKWebView)
  @available(iOS 15.0, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, decideMediaCapturePermissionsFor origin: WebKit.WKSecurityOrigin, initiatedBy frame: WebKit.WKFrameInfo, type: WebKit.WKMediaCaptureType) async -> WebKit.WKPermissionDecision
  @available(iOS 15.0, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, requestDeviceOrientationAndMotionPermissionFor origin: WebKit.WKSecurityOrigin, initiatedByFrame frame: WebKit.WKFrameInfo, decisionHandler: @escaping (WebKit.WKPermissionDecision) -> Swift.Void)
  @available(iOS 13.0, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, contextMenuConfigurationFor elementInfo: WebKit.WKContextMenuElementInfo) async -> UIKit.UIContextMenuConfiguration?
  @available(iOS 13.0, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, contextMenuWillPresentForElement elementInfo: WebKit.WKContextMenuElementInfo)
  @available(iOS 13.0, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, contextMenuForElement elementInfo: WebKit.WKContextMenuElementInfo, willCommitWithAnimator animator: any UIKit.UIContextMenuInteractionCommitAnimating)
  @available(iOS 13.0, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, contextMenuDidEndForElement elementInfo: WebKit.WKContextMenuElementInfo)
  @available(iOS 16.4, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, willPresentEditMenuWithAnimator animator: any UIKit.UIEditMenuInteractionAnimating)
  @available(iOS 16.4, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, willDismissEditMenuWithAnimator animator: any UIKit.UIEditMenuInteractionAnimating)
}
public struct TTLicense : Swift.Codable {
  public init(serviceRegion: Swift.String? = nil, serviceHost: Swift.String? = nil, clientID: Swift.String? = nil, clientKeyID: Swift.String? = nil, clientKeySecret: Swift.String? = nil, clientKey: Swift.String? = nil, accessToken: Swift.String? = nil, accountId: Swift.String? = nil, fcmToken: Swift.String? = nil, showGovCertMark: Swift.Bool? = nil)
  public var serviceRegion: Swift.String?
  public var serviceHost: Swift.String?
  public var clientID: Swift.String?, clientKeyID: Swift.String?, clientKeySecret: Swift.String?, clientKey: Swift.String?
  public var accessToken: Swift.String?
  public var accountID: Swift.String?
  public var fcmToken: Swift.String?
  public var showGovCertMark: Swift.Bool?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TTPosition : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class TTPopupWindow : UIKit.UIWindow {
  @available(iOS 13.0, *)
  @_Concurrency.MainActor @preconcurrency public init(windowScene: UIKit.UIWindowScene, level: UIKit.UIWindow.Level = .alert + 1)
  @_Concurrency.MainActor @preconcurrency public init(frame: CoreFoundation.CGRect, level: UIKit.UIWindow.Level = .alert + 1)
  @objc deinit
}
extension CoreVideo.CVBuffer : @unchecked @retroactive Swift.Sendable {
}
public enum TTPositionCode : Swift.String, Swift.Codable {
  case eyeRight
  case eyeLeft
  case toothFront
  case toothRight
  case toothLeft
  case skinEar
  case skinBody
  case skinFoot
  case skinEtc
  case jointLeftToRight
  case jointRightToLeft
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct TTResultStatus : Swift.Codable {
  public var feedbacks: [AIScan.Feedback]?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol CameraViewControllable : UIKit.UIViewController {
  func close()
  func refresh()
}
public struct TTThumbnail : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum TTPopupActionStyle {
  case `default`
  case cancel
  case destructive
  public static func == (a: AIScan.TTPopupActionStyle, b: AIScan.TTPopupActionStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class TTPopupAction {
  final public let title: Swift.String
  final public let style: AIScan.TTPopupActionStyle
  final public let handler: ((AIScan.TTPopupAction) -> Swift.Void)?
  public init(title: Swift.String, style: AIScan.TTPopupActionStyle = .default, handler: ((AIScan.TTPopupAction) -> Swift.Void)? = nil)
  public func invoke()
  @objc deinit
}
public struct AIScanModel {
}
public struct Fail : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension Foundation.Date {
  public var ttISO8601: Swift.String {
    get
  }
  public var ttSeoul: Swift.String {
    get
  }
  public var localDateString: Swift.String {
    get
  }
}
public protocol TTPopupEntry : AnyObject {
  var viewForPopup: UIKit.UIView { get }
  var completion: (() -> Swift.Void)? { get }
}
extension UIKit.UIView : AIScan.TTPopupEntry {
  @_Concurrency.MainActor @preconcurrency public var viewForPopup: UIKit.UIView {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var completion: (() -> Swift.Void)? {
    get
  }
}
public enum TTPopupPosition {
  case top
  case center
  case bottom
  public static func == (a: AIScan.TTPopupPosition, b: AIScan.TTPopupPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class TTPopupManager {
  public static var shared: AIScan.TTPopupManager {
    get
    set
  }
  public static func reset()
  public init()
  @objc deinit
  public func display(entry: any AIScan.TTPopupEntry, using attributes: AIScan.TTPopupAttributes, in scene: UIKit.UIWindowScene? = nil)
  public func dismiss(entry: any AIScan.TTPopupEntry, animate: Swift.Bool = true)
}
public class TTJSONNull : Swift.Codable, Swift.Hashable {
  public static func == (lhs: AIScan.TTJSONNull, rhs: AIScan.TTJSONNull) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public init()
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
public protocol TTAnalysisTracker {
  func trackEvent(eventName: Swift.String, properties: [Swift.String : Swift.String])
  func trackScreen(screenName: Swift.String)
}
public struct TTDetail : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class TTPopupContentsViewController : UIKit.UIViewController, AIScan.TTPopupEntry {
  @_Concurrency.MainActor @preconcurrency public var viewForPopup: UIKit.UIView {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var completion: (() -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var dismissHandler: ((AIScan.TTPopupContentsViewController) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency public func closeContentsDirectly()
  @_Concurrency.MainActor @preconcurrency public func dismissContents()
  @_Concurrency.MainActor @preconcurrency public func dismissContentsAndCallCompletion()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct TTPopupAttributes {
  public var displayDuration: Foundation.TimeInterval?
  public var position: AIScan.TTPopupPosition
  public var animationDuration: Swift.Double
  public var animationDurationOnDismiss: Swift.Double
  public var bottomOffset: CoreFoundation.CGFloat
  public var size: CoreFoundation.CGSize?
  public var cornerRadius: CoreFoundation.CGFloat
  public var isBackgroundTapForDismiss: Swift.Bool
  public var isBoardDragForDismiss: Swift.Bool
  public var isLandscape: Swift.Bool
  public var springWithDamping: CoreFoundation.CGFloat
  public var springVelocity: CoreFoundation.CGFloat
  public var dim: CoreFoundation.CGFloat
  public var initialScaleTransform: CoreFoundation.CGAffineTransform
  public init(displayDuration: Foundation.TimeInterval? = nil, position: AIScan.TTPopupPosition = .center, animationDuration: Foundation.TimeInterval = 0.3, animationDurationOnDismiss: Foundation.TimeInterval = 0.2, bottomOffset: CoreFoundation.CGFloat = 0.0, size: CoreFoundation.CGSize? = nil, cornerRadius: CoreFoundation.CGFloat = 33.0, isBackgroundTapForDismiss: Swift.Bool = false, isBoardDragForDismiss: Swift.Bool = false, isLandscape: Swift.Bool = false, springWithDamping: CoreFoundation.CGFloat = 0.5, springVelocity: CoreFoundation.CGFloat = 0.5, dim: CoreFoundation.CGFloat = 0.5, initialScaleTransform: CoreFoundation.CGAffineTransform = CGAffineTransform(scaleX: 0.5, y: 0.5))
  public static var selectAttributes: AIScan.TTPopupAttributes {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class TTProgressViewController : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public struct TTResult : Swift.Codable {
  public var feedbacks: [AIScan.Feedback]?
  public var dataValue: AIScan.TTData? {
    get
  }
  public var string: Swift.String? {
    get
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TTData : Swift.Codable {
  public var diagID: Swift.Int?
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public enum PetType : Swift.String {
  case dog
  case cat
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ModelLibType {
  case coreML
  case tflite
  public static func == (a: AIScan.ModelLibType, b: AIScan.ModelLibType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AIScanManager {
  public static let sdkVersion: Swift.String
  public static var license: AIScan.TTLicense?
  public static var analysisTracker: (any AIScan.TTAnalysisTracker)?
  public static var isNotRemoveFiles: Swift.Bool
  public static var isHiddenSkeleton: Swift.Bool
  public static var isHapticEnabled: Swift.Bool
  public static var isAnimationEnabled: Swift.Bool
  public static var albumName: Swift.String?
  public static func configure(license: AIScan.TTLicense)
  public static func configure(authFileData: Foundation.Data)
  public static func setAPNS(token: Swift.String?)
  public static func toast(_ text: Swift.String?)
  public static func alert(_ text: Swift.String?)
  public static func flashAlert()
  public static func report(isSuccess: Swift.Bool = false)
  public static func showCamera(petType: AIScan.PetType, partType: AIScan.PartType, petId: Swift.String? = nil, userId: Swift.String? = nil, recordId: Swift.String? = nil, petBirthday: Swift.String? = nil, petBreedName: Swift.String? = nil, petGender: Swift.String? = nil, petAdditionalInfo: Swift.String? = nil, guideUrl: Swift.String? = nil, isFlashMode: Swift.Bool = true, showGovCertMark: Swift.Bool? = nil, resultViewController: (any AIScan.TTResultViewCotrollable)? = nil, completion: ((Swift.String?, (any Swift.Error)?) -> Swift.Void)? = nil)
  @objc deinit
}
extension AIScan.AIScanManager {
  public static func clearUserData()
}
public struct InferenceResult {
  public let label: Swift.Int
  public let ratio: Swift.Double
  public let abnormLevel: Swift.Int
}
public struct InferenceInfo {
  public let model: AIScan.ModelType
  public let prediction: [Swift.Double]
  public func calculate() -> AIScan.InferenceResult
}
public struct TTFile : Swift.Equatable {
  public var identifier: Swift.String?
  public var name: Swift.String?
  public var type: AIScan.TTFileType
  public var detailPartType: AIScan.DetailPartType?
  public var url: Foundation.URL?
  public var path: Swift.String?
  public static func == (lhs: AIScan.TTFile, rhs: AIScan.TTFile) -> Swift.Bool
}
public enum PartType {
  case eye
  case ear
  case belly
  case foot
  case etc
  case tooth
  case joint
  public static func == (a: AIScan.PartType, b: AIScan.PartType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class TTGalleryViewController : UIKit.UIViewController, UIKit.UIScrollViewDelegate, UIKit.UICollectionViewDelegate, UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegateFlowLayout {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @_Concurrency.MainActor @preconcurrency @objc public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize
  @_Concurrency.MainActor @preconcurrency @objc public func collectionView(_ collectionView: UIKit.UICollectionView, didEndDisplaying cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency @objc public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public enum TTFileType : Swift.String {
  case image
  case video
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum DetailPartType : Swift.String, Swift.CaseIterable {
  case eyer, eyel, nose, tcenter, tleft, tright
  case ear, belly, foot, etc
  case joint
  public var positionTitle: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [AIScan.DetailPartType]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [AIScan.DetailPartType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public typealias TTResultCompletion = (Swift.Int?) -> any AIScan.TTResultViewCotrollable
public protocol TTResultViewCotrollable : UIKit.UIViewController {
  var backCompletaion: (() -> Swift.Void)? { get set }
  var closeCompletaion: (() -> Swift.Void)? { get set }
  var diagID: Swift.Int? { get set }
  var result: AIScan.TTResult? { get set }
  func close()
  func back()
}
public enum ModelType : Swift.String, Swift.CaseIterable {
  case commonEyeTeethNoseDetect
  case commonEyeClassification
  case commonTeethClassification
  case dogEyeCropBlur
  case dogTeethCropBlur
  case dogSkinClassification
  case dogSkinCropBlur
  case dogKeypoint
  case catEyeCropBlur
  case catTeethCropBlur
  case dogEyeBlepharedema
  case dogEyeBlepharoncus
  case dogEyeChemosis
  case dogEyeCherry
  case dogEyeDischarge
  case dogEyeEctropion
  case dogEyeEntropion
  case dogEyeEpiphora
  case dogEyeHyperemia
  case dogEyeOpacity
  case dogEyeUlcer
  case dogSkinErosionulcer
  case dogSkinExcoriation
  case dogSkinHyperpigmentation
  case dogSkinLichenification
  case dogTeethCalculus
  case dogTeethInflammation
  case catEyeBlepharedema
  case catEyeChemosis
  case catEyeDischarge
  case catEyeHyperemia
  case catEyeNecrosis
  case catEyeUlcer
  case catTeethCalculus
  case catTeethInflammation
  case classificationEye
  case detectEye
  case catCropBlurEye
  case dogCropBlurEye
  case classificationTooth
  case detectTooth
  case catCropBlurTooth
  case dogCropBlurTooth
  case classificationSkin
  case dogCropBlurSkin
  case detectJoint
  public var title: Swift.String? {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [AIScan.ModelType]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [AIScan.ModelType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct Feedback {
  public let timestamp: Foundation.Date
  public let modelType: AIScan.ModelType
  public var file: AIScan.TTFile?
  public var croppedURL: Foundation.URL?
  public var detailPartType: AIScan.DetailPartType?
  public var inferenceInfo: AIScan.InferenceInfo?
  public var inferenceResult: AIScan.InferenceResult?
  public var heatmapMultiArray: CoreML.MLMultiArray?
  public var heatmapImage: UIKit.UIImage?
}
extension UIKit.UIImage {
  public func overlayHeatmap(from heatmapMultiArray: CoreML.MLMultiArray, overlayFrame: CoreFoundation.CGRect? = nil, alpha: CoreFoundation.CGFloat = 0.6) -> UIKit.UIImage?
}
public class TTPromise<T> : Swift.Hashable {
  public typealias Fulfill = (T) -> Swift.Void
  public typealias Reject = (any Swift.Error) -> Swift.Void
  public typealias Executor = (_ fulfill: @escaping AIScan.TTPromise<T>.Fulfill, _ reject: @escaping AIScan.TTPromise<T>.Reject) -> Swift.Void
  public init(executor: @escaping AIScan.TTPromise<T>.Executor)
  @discardableResult
  public func then<U>(_ onFulfilled: @escaping (T) -> AIScan.TTPromise<U>) -> AIScan.TTPromise<U>
  @discardableResult
  public func then<U>(on queue: Dispatch.DispatchQueue, _ onFulfilled: @escaping (T) -> AIScan.TTPromise<U>) -> AIScan.TTPromise<U>
  @discardableResult
  public func then(_ onFulfilled: @escaping (T) -> Swift.Void) -> Self
  @discardableResult
  public func `catch`(_ onRejected: @escaping (any Swift.Error) -> Swift.Void) -> Self
  @discardableResult
  public func `catch`(on queue: Dispatch.DispatchQueue, _ onRejected: @escaping (any Swift.Error) -> Swift.Void) -> Self
  @discardableResult
  public func finally(_ onFinally: @escaping () -> Swift.Void) -> Self
  public static func == (lhs: AIScan.TTPromise<T>, rhs: AIScan.TTPromise<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @discardableResult
  public func delay(_ seconds: Foundation.TimeInterval) -> AIScan.TTPromise<T>
  public static func merge<U>(_ promises: [AIScan.TTPromise<U>]) -> AIScan.TTPromise<[U]>
  public static func sequence<U>(_ promises: [AIScan.TTPromise<U>]) -> AIScan.TTPromise<[U]>
  public static func race<U>(_ promises: [AIScan.TTPromise<U>]) -> AIScan.TTPromise<U>
  public static func any<U>(_ promises: [AIScan.TTPromise<U>]) -> AIScan.TTPromise<U>
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension AIScan.TTPromise {
  public func value() async throws -> T
}
extension Foundation.URLSession {
  public func data(for request: Foundation.URLRequest) -> AIScan.TTPromise<(Foundation.Data, Foundation.URLResponse)>
  public func data(from url: Foundation.URL) -> AIScan.TTPromise<(Foundation.Data, Foundation.URLResponse)>
}
extension AIScan.TTPositionCode : Swift.Equatable {}
extension AIScan.TTPositionCode : Swift.Hashable {}
extension AIScan.TTPositionCode : Swift.RawRepresentable {}
extension AIScan.TTPopupActionStyle : Swift.Equatable {}
extension AIScan.TTPopupActionStyle : Swift.Hashable {}
extension AIScan.TTPopupPosition : Swift.Equatable {}
extension AIScan.TTPopupPosition : Swift.Hashable {}
extension AIScan.PetType : Swift.Equatable {}
extension AIScan.PetType : Swift.Hashable {}
extension AIScan.PetType : Swift.RawRepresentable {}
extension AIScan.ModelLibType : Swift.Equatable {}
extension AIScan.ModelLibType : Swift.Hashable {}
extension AIScan.ModelType : Swift.Equatable {}
extension AIScan.ModelType : Swift.Hashable {}
extension AIScan.ModelType : Swift.RawRepresentable {}
extension AIScan.PartType : Swift.Equatable {}
extension AIScan.PartType : Swift.Hashable {}
extension AIScan.TTFileType : Swift.Equatable {}
extension AIScan.TTFileType : Swift.Hashable {}
extension AIScan.TTFileType : Swift.RawRepresentable {}
extension AIScan.DetailPartType : Swift.Equatable {}
extension AIScan.DetailPartType : Swift.Hashable {}
extension AIScan.DetailPartType : Swift.RawRepresentable {}
